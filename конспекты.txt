10.04
работа с файлами и папками
os - операционная система: знает к какой системе работаем
путь(директории папки как строка) файл в windows это /, в других |
os может сформировать адрес как надо 
folder+os.sep+folder 'папка1'+os.sep+'папка2'
проблема обратного слеша \
в одном папке много нужных файлов, все прочесть атата
import os
lst=os.listdir('.') /'.'-указание на ту папку, где лежит программа
lst=['file.txt','file.py']
for fl in lst: if fl.endswith('.txt'):f=open(fl) #открываем тхт
если папка в другом месте:
lst=os.listdir('C:/Users') - абслютный путь
относительный путь относительно той папки где файл
на уровень ниже ('папка2') на уровень выше('../папка3') #папка 3?
pth='C:/Users/'
lst=os.listdir(pth)
как импортировать собственную программу:
prog1.py (def func1(x,y): z=x+y return z)
положить prog1.py в ту же папку где prog2.py
import prog1
print(prog1.func1(4,5))
импортировать программу саму в себя import prog3.py в prog3.py #бесполезно но круто
вложенные директории, можно ли извлечь все?  - можно (но потом)
os.path.abspath('.') - получить аблосютный путь
import os
os.mkdir('nwdir')#создать папку/директорию
os.path.exists('new_folder') #возвращает true или false
import shutil
shutil.copy('dir1/f.txt','dir2') # два одинаковых файла в разных папках
shutil.move(...) # перемещение
import os     os.rename('f.txt','myf.txt')
os.path.isdir() и os.path.isfile() if os.path.isdir()/os.path.isfile():...
if '':print('1') else:print(2) => false
if 0:... => false
os.remove() - для файла, os.rmdir() - для директории и shutil.rmtree() - для созданных в процессе работы папок

17.04
os.walk('.') ('..\\')-на два уровня выше - относительные пути
('C:\...') - абсолютный путь
for root, dirs, files in os.walk('.'):
    print(root)
#enumerate-int+то что из массива
root-str
разные папки - разные итерации цикла
root-в какой мы папке
dirs-массив(вложенных папок или пустой)
files-вложенные файлы
os.path.join(root, f) - массив из пути и названия файла
1) отдает три переменных всегда
2) путь надо прописывать

for root, dirs, files in os.walk('.', topdown=False):
    print(root)
чтобы ходить вниз

задача 1:
#shutil.rmtree()
#которая удаляет выбранную папку со всеми папками и файлами внутри неё
import os
def de():
    name=input("input name: ")
    for root, dirs, files in os.walk('.'):
        for d in dirs:
            if d==name:
                os.walk('.', topdown=False)
                for f in files:
                    files.remove(os.path.join(root,f))
        print(root,dirs,files,sep="__")
de()
+ проходится по всем папкам с ней и в них лежащим
import os
import re
def main():
    num = 0
    for root, dirs, files in os.walk('.'):
        for d in dirs:
            k = 0
            if d == '[а-яёЁА-Я]+':
                k += 1
            if k == 0:
                print(d)
                num += 1
    return num
if __name__ == '__main__':
    print(main())   
15.05
выделение коллокаций
https://github.com/ElizavetaKuzmenko/Programming-and-computer-instruments/blob/master/seminars/PMI.ipynb
\r\n - перенос для блокнота, а не только \n (устаревший чутка)
IPM
split()(по пробелоподобным символам) vs split('')-по пробелам
join - склеивать только элементы массива
поэтому
' '.join([words[ind - 1], words[ind]])
a,b=4,5 можно
вертолеты вжууууух - насчет первой строки в формуле - есть несоответствия
закон ципра/цифра

d={'a':1,'b':2}
for k in sorted (d):
print(k) по ключам(ключу)
for bigram in sorted(pmi, key = lambda m: -pmi[m]): - по значениям в обратном порядке - ВОЛШЕБНАЯ ЛЯМБДА
без минуса - от меньшего к большему
pmi на words - для другой программы
for k in sorted(d, key= )
cats - категории
try except - опасные, т.к. могут скрывать ошибки
try:...
except: print('Error') - вместо try если в try ошибка - ловим ошибки

31.01
CONSPECT
true pythonists: if __name__=='__name__':main()
csv-для структурированных данных(табличек, например)
\t tsv
for line in f:cells...
//кодировки
BOM-спец символ который говорит что все что дальше идет в utf-8
inside [] - . is not . :[.] and \. . is not . [\-...-]если дефис в конце значит это не промежуток
[^a-z] - все что угодно но не это
.??
.+?a  -  ?-ограничивает квантификатор

if re.search(regex,s): print(...) //without ==true or !=none ?
r=re.search(reges,s)
if r:email=r.group()
//regex='(...)..(...)' - две группы в скобках,логин и домен: первая и вторая группа, то что возьмется из regex при соответствии
login=r.group(1) domen=r.group(2) //если не писать номер группы, возьмет все выражение
((()())) нумеруются по первой открывающейся скобке
//функция для множества вхождений: res=re.findall(regex,s) - его результат-массив строк (join-массив строку в одну строку)
число вхождений-len(re.findall(r,s)) // если групп нет нормас
res=[('..','..')] - массив кортежей res[0][0]-элемент
скобки не запоминающие: (?:...)
космическая программа китая

24.04
ошибки в питоне
print(type(x)) - узнать тип данных
join()
итерируемые - можно устраивать цикл + инкремент?
Цитатки:
ваше хладнокровие меня удивляет. хотя в нашей стране надо быть готовым ко всему?
надо предупредить техников-они на третьем этаже живут
если пока ничего не говрить мы можем вернуться к нашим питоновским делам
Продолжение
FIVE = 5 #константы с больших букв
def f1():
    a=FIVE+4
    return a
print(f1()) #сработает т.к. константа
НО:
FIVE = 5
def f1():
    FIVE+=1
    return FIVE
print(f1()) #не работает т.к. пытаемся изменить переменную
другие бы считались необъявленными в любом случае
importerror - нет модуля -> pip загрузить 
файловый объект - а в а.write(...)
шутейка: рекурсия это рекурсия
\t - tabulation e.g.: s='a\tb\tc\t' -> a  b  c  пробелы - табуляция

22.05
https://github.com/ElizavetaKuzmenko/Programming-and-computer-instruments/blob/master/seminars/TF-IDF.ipynb
"да собственно и человек не без грешен" с. Орехов
ранжирование выдачи
мимикрировать Поль Гоген // мимикрировать Поля Гогена или под Поля Гогена? Вильнюс
+ загулить "блаблабла" оффициальное видео (сначала написал оффишиал)
метрика tf-idf - частота в документе и в остальных (если везде часто - значит не специфические для документа)
прямая и обратная частота
Твиты лучше склеивать, а романы разбивать
машинное обучение на третьем или четвертом курсе (можно раньше если правильно тему курсовой выбрать)
генератор массива: не внутри функции а прямо в скобках
"деление на ноль невозможно в нашей стране" с. Орехов
Дзен Питона:
1) прекрасное лучше, чем безобразное (одно из положений)
контекстный менеджер: with open (с ним не надо закрывать файл, он сам все сделает)
lambda - все еще магия питона (функция внутри параметра, которую скрывает лямбда)

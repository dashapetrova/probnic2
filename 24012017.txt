поиск в тексте
регулярные выражения: |-или, ?-предыдущего символа может и не быть, ()-группировка, .-один любой символ
?-квантификатор(наличие или отсутствие можно назвать 0 и 1 и считать их). другие квантификаторы:
*-предыдущий символ или группа может повторяться от 0 до бесконечности раз
+-предыдущий символ или группа повторяется 1 или больше раз
.* - любой символ любое кол-во раз
экранирование \ - обратный слеш отменяет следующее(предыдущее) пример: \? \(\)
модуль re // import re
в Perl это часть языка
match - часть строки совпадающая
шаблон, pattern
муаммар каддафи
do.*e+ - омонимия: на каком е остановиться? при неоднозначности - по умолчанию брать максимум - "жадность/greed"(термин)
.+? //.*? - не жадный вариант - берет минимум
[]-один из перечисленных символов
[...-...]-один символ из диапазона
[а-яА-Яbq]-комбинировать //там нет ё надо дописать [а-яё]
экранирование метасимволов-\[,\], \(,\), \., \* и т.д.
ha(s|d|v(e|ing)) - все формы слова have
для проверки соответствия s с регулярным выражением regex:функция re.search (работает только со строками)
1)m=re.search(regex,s)
if m!=None:... // в m не лежит значение-проверка:есть или нет
2)s='abc'
if re.search('[ab]',s): print('True')
#задача: вывести только те слова, где три слога и больше
[а-я]+ - ааа, абв, где, ...
